using System;
using PSOLib;

public class RC45 : Problem
{
    public override String name()
    {
        return "RC45";
    }

    public RC45()
    {

        double[] x_u = { 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0, 90.0 };
        double[] x_l = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
        //不同V的設定
        //double[] MaxV = { 0.5, 0.5, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 10, 10, 10, 15, 15 };
        //double[] MinV = { -0.5, -0.5, -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3, -5, -5, -5, -5, -3, -10, -10, -10, -15, -15 };
        //double[] MaxV = { 15, 15, 10, 10, 5, 5, 5, 5, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0.5, 0.5 };
        //double[] MinV = { -15, -15, -10, -10, -5, -5, -5, -5, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1, -0.5, -0.5 };
        //double[] MaxV = { 0, 0, 0, 0, 5, 5, 5, 5, 3, 3, 3, 3, 2, 2, 2, 2, 5, 5, 5, 5, 5, 10, 10, 15, 15 };
        //double[] MinV = { -15, -15, -10, -10, -10, -5, -5, -5, -5, -5, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -1, -1, -1, -0.5, -0.5 };
        //double[] MaxV = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
        //double[] MinV = { -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5, -5 };
        setDims(x_u, x_l);
    }

    public override bool CheckParticle(PSOTuple pi)
    {
            //RC45-50 Declaration
            double[] x = new double[pi.X.Length];
            int[] K = new int[31] { 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37, 41, 43, 47, 49, 53, 55, 59, 61, 65, 67, 71, 73, 77, 79, 83, 85, 91, 95, 97 };

            // RC.45
            int[] S = new int[25] { 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1 };

            // RC.46
            //int[] S = new int[25] { 1,-1,1,1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,1,-1,-1,1,-1,1,1,-1 };

            // RC.47
            //int[] S = new int[25] { 1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,1,1 };

            // RC.48
            //int[] S = new int[25] { 1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,1 };

            // RC.49
            //int[] S = new int[25] { 1,-1,1,1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1 };

            // RC.50
            //int[] S = new int[25] { 1,1,1,-1,1,-1,1,-1,1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,1 };

            // RC.45
            int P = 1;

            // RC.46
            //int P = 2;

            // RC.47
            //int P = 3;

            // RC.48
            //int P = 4;

            // RC.49
            //int P = 5;

            // RC.50
            //int P = 6;

            // RC.45, RC.46, RC.48, RC.50
            double m = 0.32;

            // RC.47
            //double m = 0.36;

            // RC.49
            //double m = 0.3333;

            for (int iX = 0; iX < pi.X.Length; iX++)
            {
                x[iX] = pi.X[iX];
            }

            // 第二種限制式
            double sum = 0;
            for (int j = 0; j < pi.X.Length; j++)
            {
                sum += S[j] * Math.Cos(x[j] * Math.PI / 180);
            }
            if ((P * m - sum) > Math.Pow(10, -1)) return false; //relax過的
            if ((P * m - sum) < -Math.Pow(10, -1)) return false;

            //第一種限制式
            for (int i = 0; i < pi.X.Length - 1; i++)
            {
                if (x[i + 1] - x[i] - Math.Pow(10, -2) < 0) return false; //relax過的
            } 


        return true;
    }

    public override double GetFitness(PSOTuple pi)
    {
            // RC45-50 Declaration
            double[] x = new double[pi.X.Length];
            int[] K = new int[31] { 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37, 41, 43, 47, 49, 53, 55, 59, 61, 65, 67, 71, 73, 77, 79, 83, 85, 91, 95, 97 };

            // RC.45
            int[] S = new int[25] { 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1 };

            // RC.46
            //int[] S = new int[25] { 1,-1,1,1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,1,-1,-1,1,-1,1,1,-1 };

            // RC.47
            //int[] S = new int[25] { 1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,1,1 };

            // RC.48
            //int[] S = new int[25] { 1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,-1,1 };

            // RC.49
            //int[] S = new int[25] { 1,-1,1,1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1 };

            // RC.50
            //int[] S = new int[25] { 1,1,1,-1,1,-1,1,-1,1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,1 };

            // RC.45
            int P = 1;

            // RC.46
            //int P = 2;

            // RC.47
            //int P = 3;

            // RC.48
            //int P = 4;

            // RC.49
            //int P = 5;

            // RC.50
            //int P = 6;
            for (int iX = 0; iX < pi.X.Length; iX++)
            {
                x[iX] = pi.X[iX];
            }

            //計算分子
            double Numerator = 0;
            for (int i = 0; i < K.Length; i++)
            {
                double sum = 0;
                for (int j = 0; j < pi.X.Length; j++)
                {
                    sum += S[j] * Math.Cos(K[i] * x[j] * Math.PI / 180);
                }
                Numerator += Math.Pow(K[i], -4) * Math.Pow(sum, 2);
            }

            //計算分母
            double Denominator = 0;
            for (int i = 0; i < K.Length; i++)
            {
                Denominator += Math.Pow(K[i], -4);
            }
            Denominator = Denominator * P;
            return Math.Sqrt(Numerator / Denominator);
    }

};